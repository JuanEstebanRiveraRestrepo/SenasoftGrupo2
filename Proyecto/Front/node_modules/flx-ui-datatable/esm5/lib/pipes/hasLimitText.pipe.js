/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Pipe } from '@angular/core';
import { FlxUiDatatableService } from '../flx-ui-datatable.service';
var HasLimitText = /** @class */ (function () {
    function HasLimitText(service) {
        this.service = service;
    }
    /**
     * @param {?} array
     * @param {?} indexReached
     * @return {?}
     */
    HasLimitText.prototype.transform = /**
     * @param {?} array
     * @param {?} indexReached
     * @return {?}
     */
    function (array, indexReached) {
        var /** @type {?} */ found;
        try {
            for (var array_1 = tslib_1.__values(array), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {
                var i = array_1_1.value;
                if (i == indexReached) {
                    found = true;
                    break;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (array_1_1 && !array_1_1.done && (_a = array_1.return)) _a.call(array_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return found;
        var e_1, _a;
    };
    HasLimitText.decorators = [
        { type: Pipe, args: [{
                    name: 'haslimittext'
                },] },
    ];
    /** @nocollapse */
    HasLimitText.ctorParameters = function () { return [
        { type: FlxUiDatatableService }
    ]; };
    return HasLimitText;
}());
export { HasLimitText };
function HasLimitText_tsickle_Closure_declarations() {
    /** @type {?} */
    HasLimitText.prototype.service;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFzTGltaXRUZXh0LnBpcGUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9mbHgtdWktZGF0YXRhYmxlLyIsInNvdXJjZXMiOlsibGliL3BpcGVzL2hhc0xpbWl0VGV4dC5waXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFFLElBQUksRUFBaUIsTUFBTSxlQUFlLENBQUU7QUFDckQsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sNkJBQTZCLENBQUM7O0lBTWhFLHNCQUFtQixPQUE4QjtRQUE5QixZQUFPLEdBQVAsT0FBTyxDQUF1QjtLQUFHOzs7Ozs7SUFFcEQsZ0NBQVM7Ozs7O0lBQVQsVUFBVSxLQUFtQixFQUFDLFlBQW1CO1FBQzlDLHFCQUFJLEtBQWMsQ0FBRTs7WUFDcEIsR0FBRyxDQUFBLENBQVUsSUFBQSxVQUFBLGlCQUFBLEtBQUssQ0FBQSw0QkFBQTtnQkFBZCxJQUFJLENBQUMsa0JBQUE7Z0JBQ0wsRUFBRSxDQUFBLENBQUMsQ0FBQyxJQUFFLFlBQVksQ0FBQyxDQUFBLENBQUM7b0JBQ2YsS0FBSyxHQUFHLElBQUksQ0FBRTtvQkFDZCxLQUFLLENBQUU7aUJBQ1g7YUFDSjs7Ozs7Ozs7O1FBRUQsTUFBTSxDQUFDLEtBQUssQ0FBRTs7S0FDaEI7O2dCQWhCSixJQUFJLFNBQUM7b0JBQ0YsSUFBSSxFQUFDLGNBQWM7aUJBQ3RCOzs7O2dCQUpRLHFCQUFxQjs7dUJBRDlCOztTQU1hLFlBQVkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZScgO1xyXG5pbXBvcnQgeyBGbHhVaURhdGF0YWJsZVNlcnZpY2UgfSBmcm9tICcuLi9mbHgtdWktZGF0YXRhYmxlLnNlcnZpY2UnO1xyXG5cclxuQFBpcGUoe1xyXG4gICAgbmFtZTonaGFzbGltaXR0ZXh0J1xyXG59KVxyXG5leHBvcnQgY2xhc3MgSGFzTGltaXRUZXh0IGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybXtcclxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBzZXJ2aWNlOiBGbHhVaURhdGF0YWJsZVNlcnZpY2Upe31cclxuXHJcbiAgICB0cmFuc2Zvcm0oYXJyYXk6QXJyYXk8bnVtYmVyPixpbmRleFJlYWNoZWQ6bnVtYmVyKTogYW55e1xyXG4gICAgICAgbGV0IGZvdW5kOiBib29sZWFuIDtcclxuICAgICAgIGZvcihsZXQgaSBvZiBhcnJheSl7XHJcbiAgICAgICAgICAgaWYoaT09aW5kZXhSZWFjaGVkKXtcclxuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZSA7XHJcbiAgICAgICAgICAgICAgICBicmVhayA7XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgfVxyXG5cclxuICAgICAgIHJldHVybiBmb3VuZCA7XHJcbiAgICB9XHJcbn0iXX0=